package main

import (
	"machine"
)

const length = 30

var buffer = make([]byte, length)
var bufLen = len(buffer)
var bufIdx = 0
var bufFull = false

func main() {

	//;wvar rxdData bool = false

	for {

		/*
		   println("\nThis is from 'println( hard-coded string)'")

		   machine.UART0.WriteByte('a')
		   println("\nThe 'a' above is machine.UART0.WriteByte('a')")

		   data := []byte("This is a generated byte[] array named 'data' prepopulated with these words.")
		   machine.UART0.Write(data)
		   println("\nThe words above machine.UART0.Write(data)")
		*/
		/*
		   a, _ := machine.UART0.Read(theArray)

		   if a != 0 {
		       rxdData = true
		       str := string(theArray[:])
		       println(str)
		   } else {
		       if rxdData {
		           println("")
		           rxdData = false
		       }
		   }
		*/

		theLine, haveLine := readIncomingUsbData()
		if haveLine {
			println(theLine)
			clearBuffer()
		}
	}
}

func readIncomingUsbData() (response string, ok bool) {

	// see if there is any incoming data....
	theByte, _ := machine.UART0.ReadByte()

	// buffer is full - but a '\n' clears it
	if bufIdx >= bufLen {
		println("ERROR-FULL-CLEAR")
		clearBuffer()
		return "", false
	}

	// did we get data...
	if theByte != 0 {
		//yes. is it a complete line?
		if theByte == '\n' {
			str := string(buffer[:])
			return str, true
			//no...store it...
		} else {
			buffer[bufIdx] = theByte
			//do we have any more room to store more data?
			if bufIdx < bufLen {
				//yes... keep reading
				bufIdx++
				return "", false
			} else {
				//no, we are done
				println("ERROR-FULL")
				return "", false
			}
		}
	}

	return "", false
}

func clearBuffer() {
	buffer = make([]byte, length)
	bufIdx = 0
}
